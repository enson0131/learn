<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¦»å±æ¸²æŸ“æé«˜ Canvas ä¹¦å†™æ€§èƒ½</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #app-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #draw {
            border: 1px solid black;
            position: absolute;
            z-index: 9999;
            /* left: 0; */
        }

        #draw-content {
            border: 1px solid black;
            position: absolute;
            z-index: 9998;
            pointer-events: none;
            /* right: 0; */
        }

        #point-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }
    </style>
</head>

<body>
    <!-- åŠ¨æ€å±‚ Canvas -->
    <canvas id="draw"></canvas>
    <!-- é™æ€å±‚ Canvas -->
    <canvas id="draw-content"></canvas>
    <script>
        const elementWithCanvasCache = new WeakMap(); // ç¦»å±æ¸²æŸ“ç¼“å­˜
        const padding = 20; // ç¦»å± Canvas çš„ padding
        let start = false; // æ˜¯å¦å¼€å§‹ç»˜åˆ¶
        let points = []; // è®°å½•é¼ æ ‡ç§»åŠ¨çš„ç‚¹
        let history = []; // è®°å½•ä¹‹å‰ç»˜åˆ¶çš„å†…å®¹
        const dpr = window.devicePixelRatio || 1;
        const appContainer = document.getElementById("app-container");
        const canvas = document.getElementById('draw');
        const canvasContent = document.getElementById('draw-content');
        const pointCounter = document.getElementById("point-counter");
        const width = window.innerWidth;
        const height = window.innerHeight;
        // ä¸Šå±‚ canvas ç”¨æ¥åŠ¨æ€ç»˜åˆ¶ç»˜åˆ¶é¼ æ ‡ç§»åŠ¨çš„è½¨è¿¹
        canvas.width = Math.round(width * dpr);
        canvas.height = Math.round(height * dpr);
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        // ä¸Šå±‚ canvas end

        // ä¸‹å±‚ canvas ç”¨æ¥ä¿å­˜ç»˜åˆ¶çš„å†…å®¹
        canvasContent.width = Math.round(width * dpr);
        canvasContent.height = Math.round(height * dpr);
        canvasContent.style.width = width + "px";
        canvasContent.style.height = height + "px";
        const ctxContent = canvasContent.getContext('2d');
        ctxContent.scale(dpr, dpr);
        // ä¸‹å±‚ canvas end

        /**
         * è‡ªç”±ç”»ç¬”çš„å®ç°æ€è·¯
         * 1 ç›‘å¬é¼ æ ‡äº‹ä»¶ 
         * 2 å°†é¼ æ ‡ç§»åŠ¨çš„è½¨è¿¹è®°å½•ä¸‹æ¥
         * 3 ç„¶åå°†è¿™äº›ç‚¹è¿æ¥æˆçº¿
         */
        canvas.addEventListener('pointerdown', (e) => {
            start = true; // é€šè¿‡ç›‘å¬é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ï¼Œæ¥åˆ¤æ–­æ˜¯å¦å¼€å§‹ç»˜åˆ¶
            addPoint((e)); // å°†é¼ æ ‡æŒ‰ä¸‹çš„ç‚¹æ·»åŠ åˆ°pointsæ•°ç»„ä¸­
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!start) return; // å¦‚æœæ²¡æœ‰æŒ‰ä¸‹ï¼Œåˆ™ä¸ç»˜åˆ¶
            addPoint((e)); // å°†é¼ æ ‡ç§»åŠ¨çš„ç‚¹æ·»åŠ åˆ°pointsæ•°ç»„ä¸­
            renderUpperCanvas(ctx); // ç»˜åˆ¶ä¸Šå±‚
        });

        canvas.addEventListener('pointerup', (e) => {
            start = false;
            // å°†ä¸Šå±‚ canvas ç»˜åˆ¶çš„å†…å®¹ä¿å­˜åˆ°ä¸‹å±‚ canvas ä¸­
            history.push(points);
            points = []; // ç»˜åˆ¶å®Œæ¯•åï¼Œæ¸…ç©ºpointsæ•°ç»„
            renderLowerCanvas(ctx, ctxContent);
        });

        /**
         * åˆ é™¤ç¼“å­˜çš„ç¦»å± Canvas å…ƒç´ 
         */
        const deleteElementCache = (element) => {
            elementWithCanvasCache.delete(element);
        };
        /*
        * å°†é¼ æ ‡äº‹ä»¶çš„ç‚¹è½¬åŒ–ä¸ºç›¸å¯¹äºcanvasçš„åæ ‡ä¸Šçš„ç‚¹
        */
        function addPoint(e) {
            points.push({
                x: e.clientX,
                y: e.clientY
            });
        }

        /**
         * ç»˜åˆ¶å‡½æ•°
         * @param {*} ctx - canvas å°ºå¯¸
         * @param {*} points - é¼ æ ‡ç§»åŠ¨çš„ç‚¹é›†
         * @return è¿”å›ä¸€ä¸ª canvas å…ƒç´ 
         */
        function render(ctx, points, isOffScreen = false) {
            /*
            åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç¼“å­˜å…ƒç´ ï¼Œå­˜åœ¨çš„è¯ä½¿ç”¨ç¼“å­˜å…ƒç´ ï¼Œç»˜åˆ¶
            */
            if (isOffScreen && elementWithCanvasCache.has(points)) {
                const { canvas, x, y, width, height } = elementWithCanvasCache.get(points);
                ctx.save();
                ctx.scale(1 / dpr, 1 / dpr);
                ctx.drawImage(
                    canvas,
                    x,
                    y,
                    canvas.width,
                    canvas.height
                );
                ctx.restore();
                console.log(`å‘½ä¸­äº†ğŸ¯`)
                return;
            }

            ctx.strokeStyle = 'red'; // è®¾ç½®çº¿æ¡é¢œè‰²
            ctx.lineWidth = 6; // è®¾ç½®çº¿æ¡å®½åº¦
            ctx.lineJoin = 'round'; // è®¾ç½®çº¿æ¡è¿æ¥å¤„çš„æ ·å¼
            ctx.lineCap = 'round'; // è®¾ç½®çº¿æ¡æœ«ç«¯çš„æ ·å¼

            /*
            beginPath() æ˜¯ Canvas 2D API ä¸­çš„ä¸€ä¸ªæ–¹æ³•ï¼Œç”¨äºå¼€å§‹ä¸€ä¸ªæ–°çš„è·¯å¾„ã€‚å½“ä½ æƒ³åˆ›å»ºä¸€ä¸ªæ–°çš„è·¯å¾„æ—¶ï¼Œä½ éœ€è¦è°ƒç”¨è¿™ä¸ªæ–¹æ³•ã€‚
            ä¾‹å¦‚ï¼Œä½ å¯èƒ½ä¼šè¿™æ ·ä½¿ç”¨å®ƒï¼š
                context.beginPath();
                context.moveTo(50, 50);
                context.lineTo(200, 50);
                context.stroke();
                åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼ŒbeginPath() å¼€å§‹ä¸€ä¸ªæ–°çš„è·¯å¾„ï¼ŒmoveTo(50, 50) å°†è·¯å¾„çš„èµ·ç‚¹ç§»åŠ¨åˆ° (50, 50)ï¼ŒlineTo(200, 50) æ·»åŠ ä¸€æ¡ä»å½“å‰ä½ç½®åˆ° (200, 50) çš„çº¿ï¼Œ
                æœ€å stroke() æ–¹æ³•ç»˜åˆ¶å‡ºè·¯å¾„ã€‚
                å…¶ä¸­ context æ˜¯ä½ çš„ canvas ä¸Šä¸‹æ–‡ã€‚
            */
            ctx.beginPath(); // å¼€å§‹ç»˜åˆ¶

            ctx.moveTo(points[0].x, points[0].y); // å°†ç”»ç¬”ç§»åŠ¨åˆ°èµ·å§‹ç‚¹

            for (let i = 1; i < points.length; i++) {
                // å–ç»ˆç‚¹ï¼Œå°†ä¸Šä¸€ä¸ªç‚¹ä½œä¸ºæ§åˆ¶ç‚¹ï¼Œå¹³æ»‘è¿‡æ¸¡
                const cx = (points[i].x + points[i - 1].x) / 2;
                const cy = (points[i].y + points[i - 1].y) / 2;
                ctx.quadraticCurveTo(points[i - 1].x, points[i - 1].y, cx, cy);
            }

            ctx.stroke(); // ç»˜åˆ¶è·¯å¾„

            if (isOffScreen) {
                generateOffScreenCanvas(points);
            }
        }

        function renderUpperCanvas(ctx) {
            if (!points.length) return;
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight); // æ¸…ç©ºç”»å¸ƒ
            render(ctx, points, false);
        }

        function renderLowerCanvas(ctx, ctxContent) {
            if (!history.length) return;
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight); // æ¸…ç©ºç”»å¸ƒ
            ctxContent.clearRect(0, 0, window.innerWidth, window.innerHeight); // æ¸…ç©ºç”»å¸ƒ
            history.forEach(points => {
                render(ctxContent, points, true); // åº•å±‚ Canvas éœ€è¦ç¦»å±æ¸²æŸ“
            });
        }

        const getBoundsFromPoints = (points) => {
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;
            for (const { x, y } of points) {
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }
            return [minX, minY, maxX, maxY];
        };

        /*
        1 è·å–å½“å‰å…ƒç´ çš„åæ ‡ï¼Œç›¸å¯¹äºç¦»å± Canvas çš„åæ ‡
        2 è·å– Canvas çš„å®½é«˜
        */
        const getElementAbsoluteCoords = (points) => {
            const [minX, minY, maxX, maxY] = getBoundsFromPoints(points);
            const width = maxX - minX;
            const height = maxY - minY;
            return {
                minX,
                minY,
                width,
                height,
                points: points.map(({ x, y }) => ({ x: Math.round(x - minX), y: Math.round(y - minY) })) // è·å–å½“å‰å…ƒç´ çš„åæ ‡ï¼Œç›¸å¯¹äºç¦»å± Canvas çš„åæ ‡
            };
        };

        const distance = (x, y) => Math.abs(x - y);

        const generateOffScreenCanvas = (points) => {
            const canvas = document.createElement('canvas'); // åˆ›å»ºä¸€ä¸ªç¼“å­˜ Canvas
            const ctxContent = canvas.getContext('2d');
            ctxContent.save();
            // è·å–æœ€å°çš„ç‚¹å’Œæœ€å¤§çš„ç‚¹
            const { minX, minY, width: realWidth, height: realHeight, points: realPoints } = getElementAbsoluteCoords(points);

            canvas.width = realWidth * dpr + padding * 2;
            canvas.height = realHeight * dpr + padding * 2;
            canvas.style.width = realWidth + "px";
            canvas.style.height = realHeight + "px";
            ctxContent.translate(padding, padding); // å°†åæ ‡è½´åŸç‚¹ç§»åŠ¨åˆ°ï¼ˆ20, 20ï¼‰
            ctxContent.scale(dpr, dpr);
            ctxContent.strokeStyle = 'red'; // è®¾ç½®çº¿æ¡é¢œè‰²
            ctxContent.lineWidth = 6; // è®¾ç½®çº¿æ¡å®½åº¦
            ctxContent.lineJoin = 'round'; // è®¾ç½®çº¿æ¡è¿æ¥å¤„çš„æ ·å¼
            ctxContent.lineCap = 'round'; // è®¾ç½®çº¿æ¡æœ«ç«¯çš„æ ·å¼
            ctxContent.moveTo(realPoints[0].x, realPoints[0].y); // å°†ç”»ç¬”ç§»åŠ¨åˆ°èµ·å§‹ç‚¹
            for (let i = 1; i < realPoints.length; i++) {
                // å–ç»ˆç‚¹ï¼Œå°†ä¸Šä¸€ä¸ªç‚¹ä½œä¸ºæ§åˆ¶ç‚¹ï¼Œå¹³æ»‘è¿‡æ¸¡
                const cx = (realPoints[i].x + realPoints[i - 1].x) / 2;
                const cy = (realPoints[i].y + realPoints[i - 1].y) / 2;
                ctxContent.quadraticCurveTo(realPoints[i - 1].x, realPoints[i - 1].y, cx, cy);
            }

            ctxContent.stroke(); // ç”»çº¿
            ctxContent.restore();
            console.log(`canvas--->`, canvas.toDataURL());

            console.log(`minX - padding--->`, minX - padding);
            console.log(`minY - padding--->`, minY - padding);
            elementWithCanvasCache.set(points, {
                canvas,
                realPoints,
                x: minX * dpr - padding,
                y: minY * dpr - padding
            });
        }
    </script>
    <script src="./utils/index.js"></script>
</body>

</html>